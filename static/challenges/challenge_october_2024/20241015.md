---
date: 2024-10-15
impressions: 0
reactions: 0
comments: 0
shares: 0
followers: 0
tags: HexagonalArchitecture FunctionalCoreImperativeShell SoftwareArchitecture OctoberChallenge
---

# ğŸ›‘ Halte ! Police du Dogme : HexagonalArchitecture != Functional Core / Imperative Shell.

Les deux sont souvent associÃ©es car elles partagent des objectifs et avantages.

J'ai, parfois, galvaudÃ© les termes pour simplifier (et si tu lis jusqu'au bout, tu comprendras pourquoi).

## ğŸ§¨ Quelles diffÃ©rences ?

### 1ï¸âƒ£ Hexagonale Architecture (a k.a Port & Adapters Pattern) par Alistair Cockburn (<= 2005).

â€¢ Business, au coeur, protÃ©gÃ© de l'Infrastructure.

â€¢ FrontiÃ¨res Business/Infrastructure dÃ©finies par les Ports (Contrats d'interface publique des use cases).

â€¢ DÃ©pendances techniques "wrappÃ©es" dans les Adapters respectant lesdits contrats.

Principe clÃ© : Dependency Injection.

â€¢ Permet de repousser le choix de la solution technique (on aura eu plus de feedback et on en saura davantage).

â€¢ Permet de changer cette solution technique sans toucher au coeur de mÃ©tier (on peut Ãªtre plus innovant puisque le coup du changement est moindre).

â€¢ RÃ©duit le couplage et augmente la testabilitÃ© du code (on n'a plus besoin de ces outils de mock donc on gagne du temps).

â€¢ Permet de livrer "in memory" donc d'avoir du feedback plus rapidement (on Ã©conomise du temps et de l'argent).

### 2ï¸âƒ£ Functional Core/ Imperative Shell (parfois Functional Architecture) par Gary Bernhardt (2012).

â€¢ Business pur et isolÃ© de toute Infrastructure.

â€¢ SÃ©paration claire entre les I/O (modifie le systÃ¨me, interactions, ...) et les comportements (dÃ©crit le mÃ©tier).

â€¢ CrÃ©ation de flux applicatifs expressifs et prÃ©visibles.

Principes clÃ© : Purity + Immutability + Function Composition.

â€¢ TrÃ¨s haute testabilitÃ© du mÃ©tier en isolation de la technique.

â€¢ PrÃ©visibilitÃ© du Business (Functional Core) grÃ¢ce Ã  la puretÃ© des fonctions et l'immutabilitÃ© des structures.

â€¢ Performance (multi-threading) grandement facilitÃ©e grÃ¢ce Ã  ces deux caractÃ©ristiques puisque pas d'interfÃ©rences avec des effets et Ã©tats.

## ğŸ† Et la gagnante ?

Comme d'habitude : Ã§a dÃ©pend. Ã‡a dÃ©pend de ton business, de ton Ã©quipe, de ton contexte...

Mais, pour la rÃ©ponse au teaser : j'en parle souvent ensemble car elles se mixent extrÃªmement bien :

â€¢ Le monde extÃ©rieur (Infrastructure) reste le mÃªme.

â€¢ Tu injectes tes dÃ©pendances (souvent impures / effectful) avec tes Adapters qui respectent tes Ports.

-> Tu as ton Hexagonal Architecture avec son injection de dÃ©pendance (qui est une Imperative Shell).

â€¢ Ton Application Service / Use Case se transforme en simple composition de fonctions pures et d'I/O.

â€¢ Ton mÃ©tier se dÃ©finit par des comportements (fonctions pures) et des types (data structures immutables).

-> Tu as ton Functional Core, pur, prÃ©dictible et immutable.

ğŸ™ï¸ Non ? Tu vois un inconvÃ©nient ? Donne ton avis en commentaire.

(Ressources en commentaire)

---

Tu me dÃ©couvres ou me redÃ©couvres avec ce post ?

ğŸ› ï¸ Pendant tout le mois d'octobre, je publie un post par jour autour de NodeJS, TypeScript et d'Architecture Logicielle.

#HexagonalArchitecture #FunctionalCoreImperativeShell #SoftwareArchitecture #OctoberChallenge
