---
date: 2024-10-08
impressions: 0
reactions: 0
comments: 0
shares: 0
followers: 0
tags: DTO SoftwareArchitecture OctoberChallenge
---

# ğŸ¥Š Team DTO ou Team Anti-DTO ? Team Martin Fowler ou Team Yegor Bugayenko ?ğŸ¥Š

Qui a raison, qui a tord, je m'en fou un peu.

VoilÃ  pourquoi et comment j'utilise des DTOs dans mes apps NodeJS + TypeScript depuis plusieurs annÃ©es maintenant.

---

## ğŸ” DTO pour Data Transfer Object : qui en fait, ne sont pas des objets au sens OOP strict mais des Data Structures.

Ã€ part Ã§a, comme le nom l'indique, elles servent Ã  "TransfÃ©rer de la donnÃ©e".

---

## ğŸ—ºï¸ TransfÃ©rer de la donnÃ©e entre les couches, frontiÃ¨res ou ports de ton application selon le dÃ©coupage que tu appliques.

Comme tu l'as compris, j'utilise principalement le Pattern Port & Adapters (a.k.a. Hexagonal Architecture) donc dans mon cas mes DTOs vont me permettre de faire entrer et sortir de la donnÃ©e entre le Core / Application et l'Environnement ExtÃ©rieur.

Si tu es plutÃ´t Clean, Onion ou Functional Core / Imperative Shell, pas de problÃ¨me les DTOs sont agnostiques de ces nuances.

Que tu t'inscrives dans un paradigme OOP, FP ou autres (scripting +/- impÃ©ratif/procÃ©dural), lÃ  aussi les DTOs sont agnostiques (la forme varie un peu mais le concept et l'usage restent les mÃªmes).

---

## ğŸ¯ Alors, pourquoi les utiliser ?

- C'est l'occasion de dÃ©finir tes contrats d'entrÃ©e/sorties de ton core applicatif.

- C'est la premiÃ¨re ligne de dÃ©fense pour valider ce qui rentre dans ton application.

- C'est la derniÃ¨re ligne de vÃ©rification pour garantir ce qui sort de ton application.

- C'est une des maniÃ¨res de garantir un couplage faible entre les responsabilitÃ©s de ton application.

---

## ğŸ› ï¸ Et comment commencer ?

Pour ce qui concerne Node + TypeScript, voilÃ  mon procÃ©dÃ© (trÃ¨s banal en soi) :

- Typage fort (TypeScript / JSDoc) des paramÃ¨tres d'entrÃ©e-sortie au niveau des ports : dÃ©finit la structure des DTOs.

- Abstraction (types/interface, omit, partial...) et exploitation du Structural Typing de TS pour la flexibilitÃ©.

- Types les plus simples possibles et basÃ©s au maximum sur des valeurs (vs des rÃ©fÃ©rences) pour des comparaisons simplifiÃ©es et sans surprise.

- ImmuabilitÃ© des types des DTOs pour prÃ©venir les erreurs dÃ¨s le type-checking.

- Pas de logique ! De simples data structures (mais respectant les points au dessus normalement c'est bon).

---

## ğŸ Le bonus NodeJS (bon les autres langages le font aussi).

- SchÃ©ma de Validation au runtime (Zod, Class-Validator, ...) pour une validation rapide (cybersÃ©curitÃ©, performance, sÃ»retÃ©).

---

## ğŸ¥Š Et le fight alors ?

Bof, je le laisse aux spÃ©cialistes ou pour les commentaires ğŸ‘‡

âœ… Normalement avec tout Ã§a, tu es bien lancÃ© pour avancer step by step de maniÃ¨re safe et rapide.

Je te laisse avec la vidÃ©o de CodeOpinion en commentaire.

Dis-moi ce que tu en penses ğŸ‘‡

---

Tu me dÃ©couvres ou me redÃ©couvres avec ce post ?

ğŸ› ï¸ Pendant tout le mois d'octobre, je publie un post par jour autour de NodeJS, TypeScript et d'Architecture Logicielle.

#DTO #SoftwareArchitecture #OctoberChallenge
